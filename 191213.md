# 상속

### 상속

- 자바의 모든 객체들은 상속이라는 객체지향언어의 특징을 지원한다.

- 자바에서 생성되는 모든 객체들은 기본적으로 `java.lang.Object` 라는 객체를 상속한다.

- 클래스 다이어그램이 나올 때, 상속을 잘 사용하면 프로그램을 잘 만들 수 있다.

- 클래스 헤더에 **extends** 라는 절을 사용하는 부모클래스를 설정하는데

  **하나의 부모클래스**만 설정 가능하다.

- 조상으로부터 물려받은 메서드들은 필요에 따라 대체할 수 있다.

  **-->메서드 오버라이딩**(오버리딩이랑 다르다)

  --> **public 은 public 으로만 오버라이딩** 할 수 있다.

  (조상pub=>자식pub/조상x=자식pub/조상x=자식x)

- 어떤 클래스든 객체를 생성하면 해당 클래스만 메모리 할당하는 것이 아니라

  조상 클래스들도 메모리를 할당한다.(조상 클래스들도 객체를 생성한다)

- 모든 생성자 메서드들은 항상 조상 생성자를 생성하고 생성된다.

  (**조상의 아규먼트 안받는 생성자를 생성한다**)

  이 때, 부모 클래스에 아규먼트 있는 생성자만 있으면 오류가 난다. 

  이때는 `super` 메서드를 사용해서 부모 클래스를 직접 호출해줘야 한다.

- 자손 클래스의 객체 생성시에는 객체생성시 생성자 메서드가 생성되면 바로 조상 클래스의 생성자도 호출된다. 내부적으로는 아규먼트 없는 생성자가 호출되는데 다른 생성자를 호출하려는 경우 super()라는 메서드를 사용한다.

- 객체를 참조하는 용도 : `this`, `super`

- 객체를 초기화하는 용도로 사용되는 생성자 메서드 호출에 : **this(), super()**

- `this()`, `super()` :  **생성자 안에서만** 호출 가능

- `this`, `super` : 객체 생성 시점에 초기화 된다. 또한 **static 메서드에서 사용 불가**

  ​							non-static 메서드와 생성자 메서드에서만 사용 가능하다.



```java
package day8;
class Parent{			//java.lang.Object 클래스가 부모가 된다. 그의 멤버들을 상속받는다.	
	//부모 클래스의 메서드를 오버라이딩해서 사용 가능 (public 꼭 붙이고, 이름 똑같이, 매개변수도 똑같이!!
	int x =1, y = 2;
	public String toString() {
		return "Parent 클래스의 객체 입니당";
	}
}
class Child extends Parent {			//부모 지정하는 방법 class 헤더에 + extends + 부모class이름
	int x = 10;
	void printInfo() {
		int x = 100;
		System.out.println(x);					//100
		System.out.println(this.x);				//10
		System.out.println(super.x);			//1
		System.out.println(y);					//2	없으면 부모 위 클래스 가서 찾음
		System.out.println(this.y);				//2
		System.out.println(super.y);			//2
//		System.out.println(z);
	}
	public String toString() {
		return "Class 클래스의 객체 입니당";
	}
}
public class ParentChildTest {

	public static void main(String[] args) {
		Parent p = new Parent();
		System.out.println(p.toString());		//toString 은 객체를 문자로 바꿔주는 메서드
		System.out.println(p);
		System.out.println("출력1"+p);
		
		Card c = new Card();
		System.out.println(c.toString());
		System.out.println("출력2"+c);
		
		java.util.Date d = new java.util.Date();
		System.out.println(d.toString());
		System.out.println("출력3"+d);
		
		Child ch = new Child();
		System.out.println("출력4"+ch);
		
		ch.printInfo();
		System.out.println(ch.x);
		System.out.println(ch.y);
	}

}
```



##### * 객체 생성 프로세스(부모부터 자식 순으로 생성)

```java
package day9;


class A{
	A(){
		System.out.println("A 클래스를 객체 생성합니다.");
	}
}
class B extends A{
	B(){
		System.out.println("B 클래스를 객체 생성합니다.");
	}
}
class C extends B{
	C(){
		System.out.println("C 클래스를 객체 생성합니다.");
	}
}
public class ABCTest {

	public static void main(String[] args) {
		new C();								// 자동으로 부모들의 객체 생성

	}

}

출력 값:					//조상 생성자 먼저 생성한 걸 볼 수 잇다.
A 클래스를 객체 생성합니다.
B 클래스를 객체 생성합니다.
C 클래스를 객체 생성합니다.
```



##### * super 로 상속받는 형식, 오버라이딩 형식

```java
package day9;
public class PointTest {
	public static void main(String args[]) {
		Point3D p3 = new Point3D(1,2,3);	
		System.out.println(p3.getLocation());
	}
}
class Point {
	int x;	
	int y;
	Point(int x, int y) {		
		this.x = x;					//자신 객체 참조하는 this.
		this.y = y;
	}
	String getLocation() {
		return "x :" + x + ", y :"+ y;
	}
}
class Point3D extends Point {
	int z;
	Point3D(int x, int y, int z) {	
		super(x,y);			//x,y 의 값은 조상의 것을 호출하여 사용하고 
		this.z = z;     	//z는 본인의 것을 사용

	}
	String getLocation() {	// 오버라이딩		
        	//메서드 이름과 아규먼트값 유형이 같으면  리턴값도 같아야한다.
		return super.getLocation() + ", z :" + z;
//		return getLocation() + ", z :" + z;		
//super 가 없으면 계속 자기자신 호출해서 에러가 난다.
	}	
}
```



##### * setter 설정하여 잘못된 값 수정하여 넣기

```java
package day9;
class Book{
	String title;
	String author;
	private int price;		////*** 외부에서 접근 못하게 private 설정
	Book(){

		this("자바의 정석","남궁 성",30000);
	}
	Book(String title,String author,int price){
		this.title = title;						
		this.author = author;
		setPrice(price);		//set Price 메서드를 사용하여 제대로된 		}							  price 생성
	void setPrice(int price) {		//setter 설정 --> 무조건 void
		if (price < 0)				//setter 설정하여 잘못된 값 걸러내기
			this.price = -price;
		else
			this.price = price;
	}
	String getBookInfo() {
		return "책이름 : "+title+" "+author+" "+price;
	}
	void BookTest(){
		System.out.println(getBookInfo());
	}
}
public class BookTest {

	public static void main(String[] args) {
		Book info1 = new Book();
		info1.setPrice(-30000);
		
		System.out.println(info1.getBookInfo());

	}

}
```



##### * 실습

```java
package day9;


	class Person{
		private String name;	//자손, 클래스 모두 접근 불가- 
		Person(String name){	//Person 클래스 내에서만 사용
			this.name = name;
		}
		public String getInfo() {
			return name;
		}
}
		class Friend extends Person{
			private String phoneNum ;
			private String email;
			Friend(String name, String num, String add){
				super(name);
				this.phoneNum = num;
				this.email = add;
			}
			public String getInfo() {
				return super.getInfo()+"  "+phoneNum+"  "+email;
		}
	}
public class FriendTest {
	public static void main(String[] args) {
		
		Friend[] p = new Friend[5];
		p[0] = new Friend ("오세호","12345678","seho@seho.com");
		p[1] = new Friend ("오세호","12345678","seho@seho.com");
		p[2] = new Friend ("오세호","12345678","seho@seho.com");
		p[3] = new Friend ("오세호","12345678","seho@seho.com");
		p[4] = new Friend ("오세호","12345678","seho@seho.com");
		for(int i = 0; i<p.length ; i++)
			System.out.println(p[i].getInfo());
	}

}
```

